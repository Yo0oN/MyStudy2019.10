package MyQueue_Stack_Array;

import java.util.ArrayList;

public class ArrayEx04 {

	public static void main(String[] args) {
		// 소수구하기.
		// 예를들어 100의 약수를 구한다하면 아래와 같은 순서로 진행될것이다.
		// 1*100, 2*50, 4*25, 5*20, 10*10, 20*5, 25*4, 50*2, 100*1
		// 이때 10*10 이전과 이후는 순서만 바뀌었을뿐 같은식이다.
		// 10의 제곱 이전만 구해도 모든 약수를 알 수 있다.
		// 즉, 어떤 수의 약수를 구할 때, 어떤 수의 제곱근까지만 약수를 구해도 모든 약수를 알 수 있다는 뜻이다.
		// 위의 그림은 가로, 세로를 곱하여 100이 나오는 사각형들을 그렸을 때,
		// 100이 나오는 정사각형을 중심으로 사각형들이 대칭을 이루며 그려지므로,
		// 정사각형의 한 변의 길이까지만 약수를 구하면 모든 약수를 알수 있다 생각하면 쉽다

		// 반대로 말하면 소수를 구할 때에도,
		// 구하려는 소수의 제곱근 이하의 소수들로만 나누었을 때 나누어 떨어지지 않으면 된다는 뜻과도 같다.
		// 여기서도 사각형을 그려본다면, 정사각형 한 변의 길이까지만 소수로 나눗셈을 시도하고,
		// 그 과정에서 나누어떨어지지 않으면 소수라는 뜻이다.

		int[] prime = new int[170]; // 소수가 담길 배열
		int primenum = 0; // 방 번호

		// 2와 3은 모두가 아는 소수이다.
		prime[primenum++] = 2;
		prime[primenum++] = 3;

		// 소수 중 2를 제외하면 모든 소수는 홀수이므로, 배열에 들어있는 3 다음 홀수인 5부터 시작한다.
		for (int i = 5; i <= 1000; i += 2) {
			boolean flag = false;
			// 어차피 이후의 소수들은 홀수이므로 0번방에 들은 2의 제곱으로는 나누어도 소용없다.
			// 그러니 1번방의 3부터 시작한다.
			// 숫자 i가 배열에 있는 소수들의 제곱보다 커질경우 정사각형의 범위를 넘으니,
			// 배열 안에 있는 수의 제곱이 숫자 i보다 작은것들만 구해서 i에 나눠본다.
			for (int j = 1; prime[j] * prime[j] <= i; j++) {
				// 숫자 i를 그보다 작은 소수로 나누었을 때 나누어떨어진다면 소수가 아니다.
				if (i % prime[j] == 0) {
					flag = true;
					break;
				}
			}
			
			// 소수일경우 조건문에 들어가지 않았을 테니 flag가 false일것이다.
			// 만약 false라면 배열에 추가해준다.
			if (!flag) {
				prime[primenum++] = i;
			}
		}
		
		for (int p : prime) {
			System.out.println(p);
		}
	}
}
